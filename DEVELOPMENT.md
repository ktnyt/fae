# fae - 開発ガイド

## 開発フェーズ

### Phase 1: 基本データ構造とシンボルインデックス ✅

**完了項目:**
- [x] `types.rs` - 基本データ型定義（SearchMode, SearchResult, DisplayInfo）
- [x] `symbol_index.rs` - シンボルインデックス・メタデータストレージ実装
- [x] `display.rs` - 結果表示フォーマッター
- [x] 基本データ型とシンボルインデックスのユニットテスト
- [x] テストフィクスチャの準備

**実装済み機能:**
- ユニークシンボル名による軽量ファジー検索
- ソート済みバイナリファイルによるメタデータ管理
- O(log n)バイナリサーチ
- 重複排除ロジック
- 表示フォーマット（パス省略、コンテキストプレビュー、色分け）

### Phase 2: 検索エンジン実装

**予定項目:**
- [ ] `index_manager.rs` - ファイル発見・Tree-sitter統合・Git統合
- [ ] `searchers/content_search.rs` - コンテンツ検索（grep風）
- [ ] `searchers/file_search.rs` - ファイル名検索
- [ ] `searchers/regex_search.rs` - 正規表現検索
- [ ] 各検索エンジンのテスト

**技術要件:**
- Tree-sitterによる正確なシンボル抽出（25+言語対応）
- 並列ファイル処理による高速インデックシング
- .gitignoreサポート
- ファイルフィルタリング（バイナリ、サイズ制限、一時ファイル除外）

### Phase 3: 検索統合

**予定項目:**
- [ ] `search_coordinator.rs` - 検索リクエスト調整・結果統合
- [ ] マルチモード検索のテスト（#, >, /プレフィックス判定）
- [ ] 検索精度・性能テスト

**機能仕様:**
- プレフィックス自動検出（#, >, /）
- 検索モード間の結果統合
- スコアリングとソート最適化

### Phase 4: TUI実装

**予定項目:**
- [ ] `app.rs` - TUI Application（状態管理・描画）
- [ ] `main.rs` - TUI初期化・イベントループ
- [ ] キーボードナビゲーション実装
- [ ] リアルタイム検索実装

**UI仕様:**
- ratatui + crosstermベースのTUI
- 16msポーリング間隔でのリアルタイム応答
- Ctrl+P/N, 矢印キーナビゲーション
- Enterキーでクリップボードコピー

### Phase 5: 非同期・ファイル監視

**予定項目:**
- [ ] 非同期チャンネル通信実装
- [ ] ファイル監視・自動更新機能
- [ ] クリップボード統合
- [ ] エンドツーエンドテスト

**技術実装:**
- std::sync::mpscチャネル通信
- notifyクレートによるファイルシステム監視
- arboardクレートによるクリップボード統合

### Phase 6: 最適化と洗練

**予定項目:**
- [ ] パフォーマンス最適化（インデックス更新効率化）
- [ ] エラーハンドリング改善
- [ ] デフォルト表示（Git状態ベース）実装
- [ ] Tree-sitter統合による正確なシンボル抽出

**品質向上:**
- プログレッシブインデックシング
- メモリ効率的キャッシュシステム
- 包括的エラーハンドリング

## テスト戦略

### テストレベル

1. **ユニットテスト**: 各コンポーネントの個別機能
2. **統合テスト**: コンポーネント間の連携
3. **エンドツーエンドテスト**: CLI全体のワークフロー
4. **パフォーマンステスト**: レスポンス時間・メモリ使用量

### テスト観点

- **正常系**: 典型的な使用ケース
- **異常系**: エラーケースとリカバリ
- **境界値**: 空ファイル、巨大ファイル、特殊文字
- **セキュリティ**: パストラバーサル、悪意ある入力

### テストデータ

- **実際のプロジェクト**: 小規模な実在プロジェクト
- **合成データ**: 境界値テスト用の作成ファイル
- **エラーケース**: 破損ファイル、権限なしファイル

### 品質要求

#### パフォーマンス目標
- **検索応答時間**: 1000ファイル未満で500ms以内
- **メモリ使用量**: 通常のプロジェクトで100MB以下
- **CPU効率**: 利用可能なCPUコアを効率的に使用

#### 信頼性要求
- **エラー処理**: 不正なファイルがあっても処理継続
- **例外安全性**: パニックなしでの正常終了
- **入力検証**: 悪意ある入力に対する保護

#### 保守性要求
- **コードカバレッジ**: 90%以上
- **ドキュメント**: 全パブリック API にドキュメント
- **リファクタリング**: 各コンポーネントの独立テスト可能性

## 開発コマンド

### テスト

```bash
# 全テスト実行
cargo test

# 特定テストカテゴリ
cargo test --test indexer_test
cargo test --test searcher_test  
cargo test --test tui_test
cargo test --test cli_integration_tests
cargo test --test security_test
cargo test --test real_world_scenarios_test

# パフォーマンスベンチマーク
cargo bench

# 開発中の監視モード
cargo install cargo-watch
cargo watch -x test
```

### コード品質

```bash
# フォーマット
cargo fmt

# lintとスタイルチェック
cargo clippy

# コンパイルチェック（ビルドなし）
cargo check

# 最適化リリースビルド
cargo build --release
```

### 開発ツール

```bash
# デバッグログ
RUST_LOG=debug cargo run

# プロファイリング（カスタムベンチマークツール）
cargo run --bin profile_file -- src/tui.rs
cargo run --bin benchmark_indexing

# Tree-sitterシンボル抽出テスト
cargo run --bin test_tree_sitter_symbols -- src/
```

## 将来的な拡張ポイント

- 追加言語サポート（Go, Java, C++など）
- 設定ファイル（.fae.toml）
- プロジェクト固有のフィルタルール
- 検索結果のプレビュー機能強化
- 複数プロジェクト対応

## 重要な実装原則

### 複雑システム開発の教訓

⚠️ **重要な開発ガイドライン**:
- **期待される動作の事前定義**: 複雑な機能実装前に完全な動作仕様を明確化
- **段階的実装**: 複雑システムはシンプルなテスト可能コンポーネントから構築
- **デバッグ戦略**: ログ/トレースによる体系的デバッグ - 動作推測は避ける
- **エンドツーエンドテスト**: 個別コンポーネントでなく完全ワークフローの検証
- **アーキテクチャ理解**: 全チームメンバーが設計システムを実装前に完全理解

### 新言語追加手順

1. tree-sitter依存をCargo.tomlに追加
2. `parsers/tree_sitter_config.rs`で言語設定更新
3. `symbol_extractor.rs`でS式クエリ追加
4. `indexer.rs`でファイル拡張子パターン更新

### パフォーマンス考慮事項

- ファイル処理では必ず`rayon::par_iter()`使用
- 正規表現パターンは`OnceLock`で事前コンパイル
- 大規模コードベースでのメモリ使用量考慮
- 最適化前にカスタムベンチマークツールでプロファイリング

---

この開発ガイドは実装進捗に合わせて継続的に更新される生きた文書です。